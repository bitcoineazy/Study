print("апельсин" < "арбуз")  # True

st = 'A B C Hello world!'
for i in st:
    print(f'Порядкой номер в Юникоде символа "{i}" - {ord(i)}')

print([2, "апельсин"] < [2, "арбуз"])

# Длина слов чисел: ноль, один, два, три ...
digit_lengths = [4, 4, 3, 3, 6, 4, 5, 4, 6, 6]


# Компаратор [ - <длина слова>, <само число>]
def key_for_card(card):
    return [-digit_lengths[card], card]


cards = [2, 3, 7]
lex_sort = sorted(cards, key=key_for_card)
print(lex_sort)

print(sorted(cards, key=lambda card: [-digit_lengths[card], card]))


'''При помощи лексикографического порядка легко превратить любую сортировку в стабильную. 
Для этого мы преобразуем каждый элемент исходного массива в тройку вида [значение ключа сортировки, позиция в исходном массиве, сам элемент].
 Затем мы отсортируем массив таких троек.
Элементы, у которых значение ключа отличается, будут расположены в соответствии с этим ключом.
 Элементы, одинаковые по ключу, будут упорядочены по позиции в исходном элементе. 
 До сравнения по последнему элементу тройки дело не дойдёт, поскольку позиции у двух элементов совпасть не могут.
Например, чтобы отсортировать по длине слова ['Москва', 'Казань', 'Питер'], сохранив порядок слов одинаковой длины, сопоставим элементам тройки:
[[6,0,'Москва'], [6,1,'Казань'], [5,2,'Питер']]
При сортировке они будут упорядочены в порядке:
[5,2,'Питер'], [6,0,'Москва'], [6,1,'Казань'].
Восстановить порядок самих городов теперь можно тривиально, достаточно просто отбросить из троек лишнюю информацию. 
В итоге получаем порядок ['Питер', 'Москва', 'Казань'].
Ключи сортировки в этих тройках сохранять не обязательно, их можно вычислять на лету. 
А вот исходные позиции сохранить придётся.
Поэтому такой способ сделать сортировку стабильной потребует O(n) дополнительной памяти.
'''